<!DOCTYPE html>
<meta charset="utf-8">

<head>

	<script type="text/javascript" src="../../src/d3.js"></script>

<style>

text {
  font: bold 48px monospace;
}

.update {

  fill: #333;

}

.new {

  fill: steelblue;
}


.remove {

  fill: red;
}


</style>

</head>

<body>

<script type="text/javascript">

// datas

var data = ["Monde".split(""),
            "Figaro".split(""),
            "Times".split(""),
            "Match".split("")];

// On déclare ici les variables utiles 

var margin = {top: 40, right: 40, bottom: 40, left: 40},
    width = 1350,
    height = 500;

// Création d'un container SVG

var svg = d3.select("body").append("svg:svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + (height/2) + ")");

function update(a) {

var dataUpdate = data[a];

// Question 1 - Ecrire le d3 pattern permettant d'actualiser les éléments à chaque appel de la fonction update. Les nouveaux éléments auront la classe "new", les éléments à updater auront la classe "update", supprimer les éléments exit

// Question 2 - Entre chaque vue, garder une consistence des lettres (i.e : ne faire rentrer que les nouvelles lettres, et modifier la position des lettres déjà existantes)

// Réponse

// 1 - DATA JOIN (via la fonction data)

textUpdate = svg.selectAll("text").data(dataUpdate, function(d) {return d});

// 2 - Actualiser les anciens éléments en modifiant le texte et la classe

textUpdate
  .attr("x", function(d, i) { return i * 32; })
  .text(function(d) {return d;}).attr("class","update");

// 3 - Ajouter les éléments manquants.  (via la fonction enter()) 

textUpdate.enter().append("text")
    .attr("x", function(d, i) { return i * 32; })
    .attr("class","new")
    .text(function(d) {return d;});

// 4 - Supprimer les éléments excédentaires (via la fonction exit())

textUpdate.exit().remove();


};

</script>

</body>
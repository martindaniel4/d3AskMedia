<!DOCTYPE html>
<meta charset="utf-8">

<head>

	<script type="text/javascript" src="../../src/d3.js"></script>

<style>

text {
  font: bold 48px monospace;
}

.update {

  fill: #333;

}

.new {

  fill: steelblue;
}


.remove {

  fill: red;
}


</style>

</head>

<body>

<script type="text/javascript">

// datas

var data = ["Monde".split(""),
            "Figaro".split(""),
            "Times".split(""),
            "Match".split("")];

// On déclare ici les variables utiles 

var margin = {top: 40, right: 40, bottom: 40, left: 40},
    width = 1350,
    height = 500;

// Création d'un container SVG

var svg = d3.select("body").append("svg:svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + (height/2) + ")");

function update(a) {

  var dataUpdate = data[a];

  // Question 1 - Ecrire le d3 pattern permettant d'actualiser les éléments à chaque appel de la fonction update. Les nouveaux éléments auront la classe "new", les éléments à updater auront la classe "update", supprimer les éléments exit

  var bind = svg.selectAll('text').data(dataUpdate, function(d) { return d.toLowerCase(); });
  console.log(bind);
  
  bind
    .text(String)
    .attr('class', 'update')
    .transition()
    .duration(1500)
    .attr('y', 0)
    .attr('x', function(d, i){ return i * 30; });

  bind.enter().append('text')
    .text(String)
    .attr('class', 'new')
    .attr('y', 100)
    .transition()
    .duration(1500)
    .attr('y', 0)
    .attr('x', function(d, i){ return i * 30; })
    ;

  bind.exit()
    .attr('class', 'remove')
    .transition()
    .duration(1500)
    .attr('y', 100)
    .remove()
    ;

  // Question 2 - Entre chaque vue, garder une consistence des lettres (i.e : ne faire rentrer que les nouvelles lettres, et modifier la position des lettres déjà existantes)

};

var idx = 0;
setInterval(function(){
  update(idx++ % 4);
}, 2000);
</script>

</body>